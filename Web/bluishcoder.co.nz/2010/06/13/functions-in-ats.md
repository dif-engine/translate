# BLUISH CODER: ATSの関数

(元記事は http://bluishcoder.co.nz/2010/06/13/functions-in-ats.html です)

[ATS](http://www.ats-lang.org/) において高階関数を使うことは、
はじめは私にとって少し努力が必要でした。
正しい型が得られるように取り組まねばならなかったためです。
私は動的型付けの言語に馴染んでいて、それらの言語では無名関数を生成したり渡したりすることは簡単でした。
型推論があるため、
[Haskell](http://haskell.org/)
のような他の静的型付け言語でさえ理解するのは容易です。
ATSにおける関数の型の違いに慣れるために、私は詳細に調査しました。
私が大きなATSプログラムを作るのにそれらを正しく使いはじめるために重要だったことをこの記事では解説しようと思います。

ATSは2つの型の関数を区別しています。

* "関数": これはまさにC言語の関数に似ています。それは関数本体を表わすマシンコードを指すメモリアドレスのことです。関数はそれが生成された場所での環境を保存できません。そのため他の言語における"クロージャ"のような振舞いはしません。デフォルトでは、トップレベルで定義されたATS関数は"関数"です。関数ポインタ使って外部のC言語ルーチンに直接渡すことができます。
* "クロージャ": これは名前から値への写像である環境をともなう関数です。まさに他の動的型付け言語のクロージャと同じで、閉じられたスコープの中に値を保管することができます。クロージャを生成するためには、明示的にクロージャであることを指示する必要があります。クロージャは環境を保存するために確保されたメモリ領域を要求します。つまり、スタックにクロージャを確保するか、手動でクロージャのメモリを解放するか、GCと紐づける必要があります。スタックにクロージャを確保した場合、そのスコープから抜けると自動的にクロージャは解放されてしまいます。

関数の2つの型だけではなく、ATSは関数呼び出しによって起きるエフェクトを追跡することができます。
追跡できるエフェクトの型を次に挙げます。

* exn - その関数は例外を発生させることができます
* ntm - その関数は終了しない可能性があります
* ref - その関数は共有メモリの内容を更新する可能性があります

これは多くの組み合わせを作り、異なる型を持つ関数をもたらします。

これらのエフェクトと"関数"か"クロージャー"の分類は、
関数の定義での返値の型の前にある "<" と ">" の間に配置された "タグ" で注釈されます。
タグのない関数定義は次のようになります。

```ocaml
fun add5 (n: int): int = n+5
```

タグを追加してみると次のようになるでしょう。

```ocaml
fun add5 (n: int):<tag1,tag2,tag...> int = n+5
```

タグとして有効な値は次のものです。

* !exn - 例外を発生させる可能性がある関数
* !ntm - 終了しない可能性がある関数
* !ref - 共有メモリを更新する可能性がある関数
* 0 - 純粋な関数(エフェクトを全く持たない)
* 1 - 全てのエフェクトを持つ関数
* fun - 通常の関数、クロージャではない
* cloptr - 線形クロージャ、明示的な解放が必要
* cloref - 永続クロージャ、GCによる解放を要求

単純化のために "0" と "1" のタグは "fun", "cloptr", "cloref"
の接尾辞として使えることに注意してください。

* fun0 - 純粋な関数
* fun1 - 全てのエフェクトを持つ関数
* cloptr0 - 純粋な線形クロージャ
* cloptr1 - 全てのエフェクトを持つ線形クロージャ
* cloref0 - 純粋な
* cloref1 - 全てのエフェクトを持つ永続クロージャ

タグの使用例をいくつか見てみましょう。
Where more than one usage example is given the definitions are equivalent.

A function that takes an int, returns an int, is pure, doesn’t have side effects, doesn’t raise exceptions and will terminate:

```ocaml
fun add5 (n: int):<fun0> int = n+5
fun add5 (n: int):<fun> int = n+5
fun add5 (n: int):<> int = n+5
```

A function that takes an int, returns an int, possibly has side effects, may raise an exception, might not terminate:

xxx
