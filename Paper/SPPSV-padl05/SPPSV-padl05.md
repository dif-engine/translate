# 状態を持つ観 (view) を通じてポインタを扱う安全なプログラミング

(元論文は http://www.ats-lang.org/PAPER/SPPSV-padl05.pdf です。)

Dengping Zhu and Hongwei Xi

## 概要

ポインタを用いてメモリを直接扱うことは多くのアプリケーションにとって必要不可欠です。
けれども、ポインタの使用 (もしくは誤用)
がしばしばプログラムエラーの主要因であることもよく知られています。
そのため、プログラミングにおいてポインタを安全に使用することを効果的に強制するアプローチがこれまでさかんに探求されてきました。
ATS は、最近開発されたフレームワーク Applied Type System
に基づいた型システムを持ったプログラミング言語です。
いままでにない魅力的な ATS の機能の1つが、状態を持つ観 (view)
の概念を通してポインタを扱う安全なプログラミングのサポートです。
特にポインタ演算でさえ ATS では使用でき、しかも ATS
の型システムによって安全であることが保証されています。
この論文では、ATS のこの機能について概要を紹介し、ATS
のプロトタイプ実装におけるいくつかの興味深い例を示します。
これは状態を持つ観を通じてポインタを扱った安全なプログラミングの実用性を実証しています。

## はじめに

仕様に配慮して正確かどうかプログラムを検証することは、プログラミングにおいていまだ重要課題です。
この根本的な問題を解決するために多くのアプーチが考案されてきました
(例: ホーア論理 [Hoa69,AO91], モデル検査 [EGP99])。
しかし、一般的なソフトウェアに適用するにはしばしばそれらは高価です。
例えばホーア論理は短かいプログラムの正確さを、しばしばプログラムを複雑化させますが、証明できます。
またそのようなプログラムにはいくつか捉えにくい問題を同定できます。
より大きなプログラムを自動定理証明の助けを借りて扱うことはできますが、実際のプログラミング言語においてホーア論理をサポートするのと同様に挑戦的な課題でしょう。
一方で、プログラムの型の検証、つまり型検査、は ML や Java のような規模の言語においても実用的です。
けれども ML や Java の型は、ホーア論理と比較すると比較的限定された表現力しかありません。
そこで、私達は型検査によってより複雑な性質を捕捉して検証可能な型システムを作ろうと考えました。

重たいアプローチは、プログラムの高度に洗練された性質を捕捉できるような型システムを採用することです。
例えば、Martin-Löf によって作られた型理論に基づいた NuPrl [C+86] の型システムがあります。
このような型システムでは型は大変表現豊かですが、型検査はしばしば相当量の定理証明を伴ない、自動化しにくいものになりえます。
これは本質的に、スケーラビリティより表現力を強く意図したアプローチなのです。

私達は依存型の限定された形の概念を導入する軽いアプローチを採用しています。
そこでは型による式と実行時の式を明確に分離しています。
関数型プログラミングでは、ML の型システムを依存型を用いて改良して、関数型プログラミング言語
DML (Dependent ML) [Xi98,XP99] のデザインに辿り着きました。
命令型プログラミングでは、依存型をサポートするC言語風構文のプログラミング言語 Xanadu
をデザインしました。
別の関連する研究ですが、guarded recursive (g.r.)
データ型と呼ばれる新しい型の概念が近年導入されました [XCC03]。
(DML で開発した) 依存型の制約された型と g.r.
データ型の間の親密な類似に注目して、私達はすぐに両方の型を統合したフレームワークのデザインを開始し、
_Applied Type System (ATS)_ [Xi03,Xi04] の形式化を導きました。
私達は今、 _ATS_ に基づいた型システムを持つ ATS プログラミング言語をデザインしている最中です。
(最小限のドキュメントと多くの使用例を含む) ATS のプロトタイプはオンラインから入手できます [Xi03]。
Martin-Löf によって作られた型理論における依存型と区別するために、
ここでは _ATS スタイルの依存型_ という用語を _ATS_
における依存型を表わすのに使っていることに注意してください。

```ocaml
(* 図1. ATS における単純はコード例 *)
fun arrayAssign {a:type, n:nat} (A:array (a,n), B:array (a,n)): unit =
  let
    fun loop {i:nat | i <= n} (ind: int (i)): unit =
      if ind < length A then
        (set (B, ind, get (A, ind)); loop (ind + 1))
  in
    loop (0)
  end
```

ATS は包括的なプログラミング言語で多用なプログラミングパラダイム
(例: 関数型プログラミング, オブジェクト指向プログラミング, 命令型プログラミング,
モジュラープログラミング, メタプログラミング)
をサポートするようデザインされています。
そして ATS のコアは値渡しの関数型プログラミング言語です。
この論文では、ATS のポインタを使ったプログラミングに注目します。

今のところ依存型を用いたプログラミングは一般的ではないので、読者に依存型がどのようにプログラムの不変条件を捕捉するのに使えるのか実感してもらうために具体例を使います。
図1では、1つの配列の内容物を別の配列に割り当てる関数 arrayAssign を実装しています。
関数 arrayAssign の定義におけるヘッダは arrayAssign
に次の型が割り当てられていることを意味しています:

![](img/exp1.png)

__1__ はユニット型を表わし、おおざっぱに言うとC言語の void 型に相当します。
型 _T_ と整数 _I_ が与えられた時、array(T,i) はそれぞれの要素に型 _T_ が割り当てられたサイズ
_I_ の配列の型を表わします。
従って、arrayAssign に与えられた型は
arrayAssign が2つの同じサイズの配列にのみ適用できることを示しています。
量化 ∀ _a_ : _type_ と ∀ _n_ : _nat_ はそれぞれ _a_ と _n_
がなんらかの与えられた型と自然数でインスタンス化されることを意味しています。
内部関数 _loop_ には次の型が割り当てられています:
∀ _i_ : _nat.i_ ≤ _n_ ⊃ ( __int__ ( _i_ ) → __1__ )
整数 _I_ が与えられた時、
__int__ ( _I_ ) は _I_ を表わすシングルトン型で、
つまり型 __int__ ( _I_ ) の唯一の値は _I_ に等しくなります。
_loop_ に与えられた型は、
arrayAssign の引数のサイズである _n_ 以下の値を持つ自然数にのみ
_loop_ を適用できることを意味しています。
ATS では、
_i_ ≤ _n_ をガードと呼び、
_i_ ≤ _n_ ⊃ ( __int__ ( _i_ ) → __1__ ) をガードされた型と呼びます。
また、関数 _length_ には次の型が与えられます:

![](img/exp2.png)

xxx
