# 状態を持つ観 (view) を通じてポインタを扱う安全なプログラミング

(元論文は http://www.ats-lang.org/PAPER/SPPSV-padl05.pdf です。)

Dengping Zhu and Hongwei Xi

## 概要

ポインタを用いてメモリを直接扱うことは多くのアプリケーションにとって必要不可欠です。
けれども、ポインタの使用 (もしくは誤用)
がしばしばプログラムエラーの主要因であることもよく知られています。
そのため、プログラミングにおいてポインタを安全に使用することを効果的に強制するアプローチがこれまでさかんに探求されてきました。
ATS は、最近開発されたフレームワーク Applied Type System
に基づいた型システムを持ったプログラミング言語です。
いままでにない魅力的な ATS の機能の1つが、状態を持つ観 (view)
の概念を通してポインタを扱う安全なプログラミングのサポートです。
特にポインタ演算でさえ ATS では使用でき、しかも ATS
の型システムによって安全であることが保証されています。
この論文では、ATS のこの機能について概要を紹介し、ATS
のプロトタイプ実装におけるいくつかの興味深い例を示します。
これは状態を持つ観を通じてポインタを扱った安全なプログラミングの実用性を実証しています。

## 1. はじめに

仕様に配慮して正確かどうかプログラムを検証することは、プログラミングにおいていまだ重要課題です。
この根本的な問題を解決するために多くのアプーチが考案されてきました
(例: ホーア論理 [Hoa69,AO91], モデル検査 [EGP99])。
しかし、一般的なソフトウェアに適用するにはしばしばそれらは高価です。
例えばホーア論理は短かいプログラムの正確さを、しばしばプログラムを複雑化させますが、証明できます。
またそのようなプログラムにはいくつか捉えにくい問題を同定できます。
より大きなプログラムを自動定理証明の助けを借りて扱うことはできますが、実際のプログラミング言語においてホーア論理をサポートするのと同様に挑戦的な課題でしょう。
一方で、プログラムの型の検証、つまり型検査、は ML や Java のような規模の言語においても実用的です。
けれども ML や Java の型は、ホーア論理と比較すると比較的限定された表現力しかありません。
そこで、私達は型検査によってより複雑な性質を捕捉して検証可能な型システムを作ろうと考えました。

重たいアプローチは、プログラムの高度に洗練された性質を捕捉できるような型システムを採用することです。
例えば、Martin-Löf によって作られた型理論に基づいた NuPrl [C+86] の型システムがあります。
このような型システムでは型は大変表現豊かですが、型検査はしばしば相当量の定理証明を伴ない、自動化しにくいものになりえます。
これは本質的に、スケーラビリティより表現力を強く意図したアプローチなのです。

私達は依存型の限定された形の概念を導入する軽いアプローチを採用しています。
そこでは型による式と実行時の式を明確に分離しています。
関数型プログラミングでは、ML の型システムを依存型を用いて改良して、関数型プログラミング言語
DML (Dependent ML) [Xi98,XP99] のデザインに辿り着きました。
命令型プログラミングでは、依存型をサポートするC言語風構文のプログラミング言語 Xanadu
をデザインしました。
別の関連する研究ですが、guarded recursive (g.r.)
データ型と呼ばれる新しい型の概念が近年導入されました [XCC03]。
(DML で開発した) 依存型の制約された型と g.r.
データ型の間の親密な類似に注目して、私達はすぐに両方の型を統合したフレームワークのデザインを開始し、
_Applied Type System (ATS)_ [Xi03,Xi04] の形式化を導きました。
私達は今、 _ATS_ に基づいた型システムを持つ ATS プログラミング言語をデザインしている最中です。
(最小限のドキュメントと多くの使用例を含む) ATS のプロトタイプはオンラインから入手できます [Xi03]。
Martin-Löf によって作られた型理論における依存型と区別するために、
ここでは _ATS スタイルの依存型_ という用語を _ATS_
における依存型を表わすのに使っていることに注意してください。

```ocaml
(* 図1. ATS における単純はコード例 *)
fun arrayAssign {a:type, n:nat} (A:array (a,n), B:array (a,n)): unit =
  let
    fun loop {i:nat | i <= n} (ind: int (i)): unit =
      if ind < length A then
        (set (B, ind, get (A, ind)); loop (ind + 1))
  in
    loop (0)
  end
```

ATS は包括的なプログラミング言語で多用なプログラミングパラダイム
(例: 関数型プログラミング, オブジェクト指向プログラミング, 命令型プログラミング,
モジュラープログラミング, メタプログラミング)
をサポートするようデザインされています。
そして ATS のコアは値渡しの関数型プログラミング言語です。
この論文では、ATS のポインタを使ったプログラミングに注目します。

今のところ依存型を用いたプログラミングは一般的ではないので、読者に依存型がどのようにプログラムの不変条件を捕捉するのに使えるのか実感してもらうために具体例を使います。
図1では、1つの配列の内容物を別の配列に割り当てる関数 arrayAssign を実装しています。
関数 arrayAssign の定義におけるヘッダは arrayAssign
に次の型が割り当てられていることを意味しています:

![](img/exp1.png)

__1__ はユニット型を表わし、おおざっぱに言うとC言語の void 型に相当します。
型 _T_ と整数 _I_ が与えられた時、 __array__ ( _T_ , _i_ )
はそれぞれの要素に型 _T_ が割り当てられたサイズ _I_ の配列の型を表わします。
従って、 _arrayAssign_ に与えられた型は
_arrayAssign_ が2つの同じサイズの配列にのみ適用できることを示しています。
量化 ∀ _a_ : _type_ と ∀ _n_ : _nat_ はそれぞれ _a_ と _n_
がなんらかの与えられた型と自然数でインスタンス化されることを意味しています。
内部関数 _loop_ には次の型が割り当てられています:
∀ _i_ : _nat.i_ ≤ _n_ ⊃ ( __int__ ( _i_ ) → __1__ ) 。
整数 _I_ が与えられた時、
__int__ ( _I_ ) は _I_ を表わすシングルトン型で、
つまり型 __int__ ( _I_ ) の唯一の値は _I_ に等しくなります。
_loop_ に与えられた型は、
_arrayAssign_ の引数のサイズである _n_ 以下の値を持つ自然数にのみ
_loop_ を適用できることを意味しています。
ATS では、
_i_ ≤ _n_ をガードと呼び、
_i_ ≤ _n_ ⊃ ( __int__ ( _i_ ) → __1__ ) をガードされた型と呼びます。
また、関数 _length_ には次の型が与えられます:

![](img/exp2.png)

そしてその配列の添字関数 _get_ と配列の更新関数 _set_ には次の型が与えられます:

![](img/exp3.png)

これは配列にアクセスするインデックスが配列の境界の中におさまっていることを示しています。

ポインタを用いた安全なプログラミングをサポートするために、ATS
にはメモリレイアウトをモデル化するために _状態を持つ観 (view)_ と呼ばれる概念が導入されています。
型 _T_ とアドレス _L_ が与えられたとき、アドレス _L_ に保存された型 _T_
の値を表わす (状態を持つ) 観を表現するために _T_ @ _L_ を用います。
これはプリミティブな観として唯一の形で、それ以外全ての観はこのようなプリミティブな観の上に構築されています。
例えば、型 _T_ の値ともう一つの型 _T'_ の値がそれぞれアドレス _L_ と _L_ + 1
に格納されていることを意味する観 ( _T_ @ _L_, _T'_ @ ( _L_ + 1)) を作ることができます。
状態を持つ観は型に似ていて、ある項に割り当てることができます。
それは状態を持つ観の証明の項 (もしくは単に証明) としばしば呼ばれます。
観の証明は、生成されたり消費されたりするようなリソースの形のように扱われます。
特に、観の上における型理論は線形論理 [Gir87] に基づいています。

関数によっては適用されるとき、状態を持つ観の証明を要求します。
それらは実行時に状態を持つ観を変化させるのです。
例えば、関数 _getVar_ と _setVar_ には次の型が与えられています:

![](img/exp4.png)

ここでは、与えられたアドレス _L_ を指すポインタを表わすシングルトン型として
__ptr__ ( _L_ ) を使っています。
_getVar_ に割り当てられた型は、なんらかの型 _T_ とアドレス _L_
についての観の証明 _T_ @ _L_ と型 __ptr__ ( _L_ ) の値を取り、観の証明
_T_ @ _L_ と型 _T_ の値を返す関数を意味しています。
この場合、観の証明 _T_ @ _L_ は消費されて別の観の証明 _T_ @ _L_
が生成される、と言えます。
証明は型検査を行なうためにコンパイル時でのみ使われ、それらは実行時には必要なく有効でさえないことを強調させてください。
与えられたポインタから読み出す関数として _getVar_ をここでは使っています。
_getVar_ の証明引数は _getVar_
に渡されるポインタが指すアドレスにある型の値が格納されていることを示しているので、その証明引数は本質的にそのポインタが宙ぶらりんなポインタ
(dangling pointer) ではないと見なすことに注意してください。

関数 _setVar_ に割り当てられた型も似た作法で理解できます:
_setVar_ は、型 _T1_ とアドレス _L_ における観の証明 _T1_ @ _L_ と型 _T2_ の値と型 __ptr__ ( _L_ )
の値を取り、観の証明 _T2_ @ _L_ と (型 __1__ の) ユニットを返します。
この場合、観の証明 _T1_ @ _L_ は消費されて別の観の証明 _T2_ @ _L_
が生成される、と言えます。
_setVar_ は与えられたアドレスに書き込む関数として使われ、
この変更は関数 _setVar_ が呼び出される前後の状況を正確に反映しています:
呼び出し前では型 _T1_ の値が _L_ に格納されており、呼び出し後では型
_T2_ の値が _L_ に格納されていることになります。

関数 _allocVar_ と _freeVar_ はそれぞれあるメモリ単位を確保と解放します。
それらの型は次のように与えられます:

![](img/exp5.png)

トップ型を表わすのに __top__ を使います。
つまり全ての型は __top__ のサブタイプになります。
_allocVar_ は呼び出されると、どこかのアドレス _L_ について観の証明 __top__ @ _L_ と型 __ptr__ ( _L_ ) のポインタを返します。
そのポインタを通じた書き込み操作を行なうのであれば、この証明が必要になります。
もう一方で _freeVar_ を呼び出すとポインタにアクセスすることができなくなります。

```ocaml
(* 図2. 単純なスワップ関数 *)
fun swap {t1:type, t2:type, l1:addr, l2:addr}
    (pf1: t1 @ l1, pf2: t2 @ l2 | p1: ptr (l1), p2: ptr (l2))
  : '(t1 @ l2, t2 @ l1 | unit) =
  let
    val '(pf1 | tmp1) = getVar (pf1 | p1)
    val '(pf2 | tmp2) = getVar (pf2 | p2)
    val '( pf1' | _ ) = setVar (pf1 | p1, tmp2)
    val '( pf2' | _ ) = setVar (pf2 | p2, tmp1)
  in
    '(pf2', pf1' | '())
  end
```

例として、図2で実装されている関数は2つの異なるアドレスに保存されている内容物をスワップします。
タプルを作るのには '(...) を使います。クオート記号 (') は単に構文解析のためです。
またバー記号 (|) は (コンマ記号 (,) のように) 区切りとして使われます。

上記の実装では証明は明確にコントロールされていて、プログラマの重荷になりうることに注意してください。
ATS では、暗黙的に証明を消費したり生成したりすることを許しています。
例えば、ATS において図2の関数は次のように実装することもできます:

```ocaml
fun swap {t1:type, t2:type, l1:addr, l2:addr}
    (pf1: t1 @ l1, pf2: t2 @ l2 | p1: ptr (l1), p2: ptr (l2))
  : '(t1 @ l2, t2 @ l1 | unit) =
  let val tmp := !p1 in p1 := !p2; p2 := tmp end
```

このとき _getVar_ を表わすのに ! を、
_setVar_ を表わすのに := をを使い、暗黙的な作法によって証明を扱います。

この論文の主な目的は、型理論に対して正式なトレーニングを十分に積んでいるかどうかにかかわらず、幅広い読者に
ATS を理解してもらうことです。
そこで脅えさせるような ATS
の理論的詳細にはできるかぎり踏み込まず、ポインタを用いた安全なプログラミングをサポートする状態を持つ観の使用のすっきりと直感的な導入を得ようと努力することにします。
ATS の技術面に興味がある読者には、より詳細を理解するために [Xi03] をおすすめします。
また、ATS のプロトタイプ実装と多くの興味深い使用例はオンラインから入手できます [Xi03]。

この論文の残りは次のように編成されています。
2節では、ATS におけるいくつかの (一般的でない) 型について概要を示します。
3節では、ATS
において安全にポインタを用いてどのようにプログラミングを行なうか示すために、いくつかの例を紹介します。
4節ではいくつか関連研究について言及し、5節で結論を述べます。

## 2. ATS/SV について簡単に


xxx
